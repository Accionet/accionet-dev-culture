(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{350:function(e,a,r){"use strict";r.r(a);var t=r(26),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"gitflow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gitflow"}},[e._v("#")]),e._v(" Gitflow")]),e._v(" "),r("p",[e._v("El "),r("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/what-is-version-control",target:"_blank",rel:"noopener noreferrer"}},[e._v("control de versiones"),r("OutboundLink")],1),e._v(" lo gestionamos con "),r("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/what-is-git",target:"_blank",rel:"noopener noreferrer"}},[e._v("git"),r("OutboundLink")],1),e._v(". Esta maravillosa herramienta desarrollada con "),r("a",{attrs:{href:"https://es.wikipedia.org/wiki/Linus_Torvalds",target:"_blank",rel:"noopener noreferrer"}},[e._v("Linus Torvalds"),r("OutboundLink")],1),e._v(" nos permite trabajar en equipo e ir gestionando los cambios al código. Pero, ¿cómo lo usamos?")]),e._v(" "),r("p",[e._v("En Accionet seguimos la metodología "),r("a",{attrs:{href:"https://medium.com/@okandavut/what-is-gitflow-c0be7a659992",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitFlow"),r("OutboundLink")],1),e._v(". Por si no la conocen dejamos unos artículos que pueden ser de interés:")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://medium.com/@okandavut/what-is-gitflow-c0be7a659992",target:"_blank",rel:"noopener noreferrer"}},[e._v("What is GitFlow?"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://bemobile.es/blog/2016/11/gitflow-mejora-la-gestion-de-tu-repositorio-git/#:~:text=GitFlow%20es%20un%20workflow%20y,ramas%20en%20nuestros%20repositorios%20Git.",target:"_blank",rel:"noopener noreferrer"}},[e._v("GITFLOW MEJORA LA GESTIÓN DE TU REPOSITORIO GIT"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://cleventy.com/que-es-git-flow-y-como-funciona/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Qué es Git flow y cómo funciona"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("En simple gitflow define cúando crear una rama (branch) y cómo gestionar las distintas ramas para minimizar conflictos.")]),e._v(" "),r("h2",{attrs:{id:"branches"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#branches"}},[e._v("#")]),e._v(" Branches")]),e._v(" "),r("p",[e._v("En concreto lo que Gitflow propone es 2 branches principales:")]),e._v(" "),r("ul",[r("li",[e._v("master: Esta es la branch principal y debe contener el mismo código que está en producción actualmente.")]),e._v(" "),r("li",[e._v('develop: Esta es la branch donde están todas las cosas que están "listas" para producción. Para rapidez de tecleo, en Accionet a esta la llamados '),r("code",[e._v("dev")]),e._v(".")])]),e._v(" "),r("p",[e._v('Nunca desarrollamos o escribimos código directamente en una de estas branches. Para desarrollar existen dos "familias" de branches:')]),e._v(" "),r("h3",{attrs:{id:"feature-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#feature-branch"}},[e._v("#")]),e._v(" Feature Branch")]),e._v(" "),r("h4",{attrs:{id:"funcion"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#funcion"}},[e._v("#")]),e._v(" Función")]),e._v(" "),r("p",[e._v("Cuando tenemos que hacer una nueva funcionalidad, creamos una nueva branch. Siempre hacer 1 funcionalidad por cada branch. No acumular funcionalidades en una branch.")]),e._v(" "),r("h4",{attrs:{id:"salir-desde"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#salir-desde"}},[e._v("#")]),e._v(" Salir desde")]),e._v(" "),r("p",[e._v("Siempre salir desde "),r("code",[e._v("dev")]),e._v(" jamás desde "),r("code",[e._v("master")]),e._v(":")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b myFeature dev\n")])])]),r("h4",{attrs:{id:"volver-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volver-a"}},[e._v("#")]),e._v(" Volver A")]),e._v(" "),r("p",[e._v("Una vez que hayamos desarrollado la funcionalidad y testeado adecuadamente, debemos hacer una "),r("a",{attrs:{href:"#pull-request-code-review"}},[e._v("Pull Request")]),e._v(" a "),r("code",[e._v("dev")]),e._v(" no a "),r("code",[e._v("master")]),e._v(".")]),e._v(" "),r("h4",{attrs:{id:"convencion-de-nombre"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#convencion-de-nombre"}},[e._v("#")]),e._v(" Convención de Nombre")]),e._v(" "),r("p",[e._v("En Accionet no tenemos una convención de nombre muy estricta sobre cómo se debe llamar cada branch. Pero como regla general:")]),e._v(" "),r("ul",[r("li",[e._v("En lo posible, evitar nombres largos.")]),e._v(" "),r("li",[e._v("Evitar nombres solo con número o alguna codificación que no tenga relación directa con lo desarrollado.")]),e._v(" "),r("li",[e._v("Auto descriptivo, que con el nombre de un indicio sobre lo que se está desarrollando.")]),e._v(" "),r("li",[e._v("Nombres en Inglés.")])]),e._v(" "),r("div",{staticClass:"custom-block danger"},[r("p",{staticClass:"custom-block-title"},[e._v("JAMÁS HACER")]),e._v(" "),r("p",[e._v('En rojo y grande, un práctica muy común que se debe evitar es nombrar las branches según quién es el desarrollador. Si Juan va a desarrollar una funcionalidad, que la branch no se llame "Juan".')])]),e._v(" "),r("h5",{attrs:{id:"no-hacer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#no-hacer"}},[e._v("#")]),e._v(" No Hacer")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b addImagesToProfileOfUser dev   # muy largo\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b 12345 dev   # solo números\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b feature12345 dev    # no es auto descriptivo\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b agregarImagen dev   # en inglés\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b juan dev   # indicar qué, no quién\n")])])]),r("h5",{attrs:{id:"hacer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hacer"}},[e._v("#")]),e._v(" Hacer")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b profileImages dev\n")])])]),r("h3",{attrs:{id:"hotfix-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hotfix-branch"}},[e._v("#")]),e._v(" Hotfix Branch")]),e._v(" "),r("h4",{attrs:{id:"funcion-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#funcion-2"}},[e._v("#")]),e._v(" Función")]),e._v(" "),r("p",[e._v("No todos los cambios al código son nuevas funcionalidades. Si se debe arreglar un typo, bug u otro, se hace a través de una hotfix branch. Mantener estas branches chicas, solo deben arreglar el error puntuar que se busca corregir.")]),e._v(" "),r("h4",{attrs:{id:"salir-desde-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#salir-desde-2"}},[e._v("#")]),e._v(" Salir Desde")]),e._v(" "),r("p",[e._v("Usualmente desde "),r("code",[e._v("master")]),e._v(". Si el error fue encontrado en "),r("code",[e._v("dev")]),e._v(" y todavía no está en "),r("code",[e._v("master")]),e._v(" entonces se puede salir desde "),r("code",[e._v("dev")]),e._v(".")]),e._v(" "),r("h4",{attrs:{id:"volver-a-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volver-a-2"}},[e._v("#")]),e._v(" Volver A")]),e._v(" "),r("p",[e._v("Se debe volver desde dónde se salió. Es decir si se salió de "),r("code",[e._v("dev")]),e._v(", se debe volver a "),r("code",[e._v("dev")]),e._v(", si se salió desde "),r("code",[e._v("master")]),e._v(" se debe volver a "),r("code",[e._v("master")]),e._v(". En este último caso, luego se debe actualizar "),r("code",[e._v("dev")]),e._v(", para que "),r("code",[e._v("dev")]),e._v(" esté al día con "),r("code",[e._v("master")]),e._v(".")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Regla de Oro")]),e._v(" "),r("p",[e._v("Todo el código que está en "),r("code",[e._v("master")]),e._v(" debe estar en "),r("code",[e._v("dev")]),e._v(" a todo momento.")])]),e._v(" "),r("h4",{attrs:{id:"convencion-de-nombre-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#convencion-de-nombre-2"}},[e._v("#")]),e._v(" Convención de Nombre")]),e._v(" "),r("p",[e._v("La misma convención de nombre que aplica para "),r("a",{attrs:{href:"#feature-branch"}},[e._v("Feature Branch")]),e._v('. La única excepción es que se debe empezar con la palabra "hotfix". Por ejemplo:')]),e._v(" "),r("h5",{attrs:{id:"no-hacer-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#no-hacer-2"}},[e._v("#")]),e._v(" No Hacer")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b fixTypoLogin master\n")])])]),r("h5",{attrs:{id:"hacer-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hacer-2"}},[e._v("#")]),e._v(" Hacer")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b hotfixFixTypoLogin master\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("git checkout -b hotfix-fixTypoLogin master\n")])])]),r("h3",{attrs:{id:"merge-a-master"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#merge-a-master"}},[e._v("#")]),e._v(" Merge a Master")]),e._v(" "),r("p",[e._v("Solo se debe mergear a "),r("code",[e._v("master")]),e._v(" una Hotfix o bien "),r("code",[e._v("dev")]),e._v(", una vez que esté listo para producción. Bueno, en verdad jamás hacer un merge a "),r("code",[e._v("master")]),e._v(", siempre usar una "),r("a",{attrs:{href:"#pull-request-code-review"}},[e._v("Pull Request")]),e._v(".")]),e._v(" "),r("h2",{attrs:{id:"pull-request-code-review"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pull-request-code-review"}},[e._v("#")]),e._v(" Pull Request + Code Review")]),e._v(" "),r("p",[e._v("Para pasar código a "),r("code",[e._v("master")]),e._v(" y a "),r("code",[e._v("dev")]),e._v(" siempre lo hacemos a través de Pull Request. Esto nos permite tener control de que no cualquier basura llegue a las branches principales, poniendo reglas, tanto subjetivas cómo objetivas, que nos permitan revisar si cómo equipo aceptamos el cambio o no.")]),e._v(" "),r("h3",{attrs:{id:"continuous-integration"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#continuous-integration"}},[e._v("#")]),e._v(" Continuous Integration")]),e._v(" "),r("p",[e._v("Esto se suele llamar Integración Continua. Citando a "),r("a",{attrs:{href:"https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua",target:"_blank",rel:"noopener noreferrer"}},[e._v("wikipedia"),r("OutboundLink")],1),e._v(":")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Integración Continua")]),e._v(" "),r("p",[e._v("Es una práctica de ingeniería de software que consiste en hacer integraciones automáticas de un proyecto lo más a menudo posible para así poder detectar fallos cuanto antes. Entendemos por integración la compilación y ejecución de pruebas de todo un proyecto")])]),e._v(" "),r("p",[e._v("En concreto, cada vez que se sube un commit a github, se revisan lo siguiente:")]),e._v(" "),r("ul",[r("li",[e._v("Test: Revisa que todos los tests pasen. Esto permite detectar fallos tempranamente.")]),e._v(" "),r("li",[e._v("Coverage: Cobertura de los tests. Accionet exige un mínimo de cobertura que los tests deben tener. No sirve tener tests si estos no cubren todos los casos.")]),e._v(" "),r("li",[e._v("Linter: Revisa los errores de sintaxis y estilo del código. Se permiten "),r("code",[e._v("warnings")]),e._v(" pero no "),r("code",[e._v("errors")]),e._v(". Más información sobre el linter "),r("RouterLink",{attrs:{to:"/code.html#linter"}},[e._v("acá")]),e._v(".")],1)]),e._v(" "),r("p",[e._v("Si alguno de estos arroja un error, no dejará mergear la Pull Request hasta que el error haya sido arreglado. De esta forma nos aseguramos que nuestro código mantenga unos estándares mínimos.")]),e._v(" "),r("h3",{attrs:{id:"branch-actualizada"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#branch-actualizada"}},[e._v("#")]),e._v(" Branch Actualizada")]),e._v(" "),r("p",[e._v("Además de las condiciones de Continuous Integration, la branch que se está comparando (es decir la que se busca mergear) debe estar al día con la branch base. Es decir todos los commits de la branch base deben estar en la branch comparada.")]),e._v(" "),r("h3",{attrs:{id:"code-review"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#code-review"}},[e._v("#")]),e._v(" Code Review")]),e._v(" "),r("p",[e._v('Todas las reglas anteriores son objetivas, es decir cumple o no cumple. Hay una última condición que es subjetiva y muy importante: Code Review. Un miembro del equipo debe darle el "visto bueno" a la Pull Request, es decir debe revisar el código que se busca agregar y revisar que sea fácil de comprender, que no tenga fallas ni '),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Code_smell#:~:text=In%20computer%20programming%2C%20a%20code,%2C%20developer%2C%20and%20development%20methodology.&text=It%20is%20also%20a%20term%20used%20by%20agile%20programmers.",target:"_blank",rel:"noopener noreferrer"}},[e._v("code smells"),r("OutboundLink")],1),e._v(". Esta es una buenísima oportunidad, para tanto el revisador como para el revisado, para aprender el uno y del otro.")]),e._v(" "),r("h3",{attrs:{id:"cada-cuanto-hacer-una-pull-request"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cada-cuanto-hacer-una-pull-request"}},[e._v("#")]),e._v(" Cada Cuanto Hacer una Pull Request")]),e._v(" "),r("p",[e._v("Hacerle Code Review a una Pull Request muy larga es un infierno. Por lo mismo las Pull Requests deben ser periódicas, concisas y cortas. Pero esto no se debe forzar, una Pull Request indica que la funcionalidad en cuestión está lista, jamás hacer una Pull Request si la funcionalidad todavía no está lista. Debe hacerse un trabajo conjunto por parte de todo el equipo para dividir las funcionalidades grandes en pequeñas funcionalidad e ir armando de a poco, con varias Pull Requests.")]),e._v(" "),r("h2",{attrs:{id:"commits"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commits"}},[e._v("#")]),e._v(" Commits")]),e._v(" "),r("h3",{attrs:{id:"cuando"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cuando"}},[e._v("#")]),e._v(" Cuándo")]),e._v(" "),r("p",[e._v("Una difícil pregunta: ¿cuánto y cuándo commitear? Viendo parafraseando la respuesta a "),r("a",{attrs:{href:"https://softwareengineering.stackexchange.com/questions/74764/how-often-should-i-do-you-make-commits",target:"_blank",rel:"noopener noreferrer"}},[e._v("esta"),r("OutboundLink")],1),e._v(" pregunta:")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Cúanto Commitear")]),e._v(" "),r("p",[e._v("Uno no debe hacer commits baso en tiempo, sino que basado en cuando uno agregó o bien arregló algo. Agregaste un método que funciona, arreglaste un typo, arreglaste cosas de estilo, etc.")])]),e._v(" "),r("p",[e._v("Como regla general los commits deben ser atómicos, deben englobar un solo cambio. Yo suelo hacer la analogía cuando uno esta trabajando en un archivo Word y decide apretar el botón "),r("em",[e._v("save")]),e._v(". Hacer un commit es equivalente a apretar "),r("em",[e._v("save")]),e._v(", uno no apreta save cada vez que uno ingresa una letra pero tampoco uno escribe un ensayo de 5 planas sin apretar "),r("em",[e._v("save")]),e._v(".")]),e._v(" "),r("h3",{attrs:{id:"formato"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#formato"}},[e._v("#")]),e._v(" Formato")]),e._v(" "),r("p",[e._v("Cada commit debe tener un mensaje, si bien en git esto es opcional, ¡en Accionet es obligatorio! Este mensaje debe explicar el cambio que se hizo. Accionet sigue la "),r("a",{attrs:{href:"https://la-guia.platan.us/herramientas/git",target:"_blank",rel:"noopener noreferrer"}},[e._v("guía"),r("OutboundLink")],1),e._v(" de platanus sobre commits.")]),e._v(" "),r("p",[e._v("Pero en concreto, deben ser en inglés, no muy largos y tener el siguiente formato:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  tipo(contexto): descripción\n")])])]),r("h4",{attrs:{id:"tipo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tipo"}},[e._v("#")]),e._v(" Tipo")]),e._v(" "),r("p",[e._v("El tipo corresponde a que se debe el commit:")]),e._v(" "),r("ul",[r("li",[e._v("feat: Un nuevo feature")]),e._v(" "),r("li",[e._v("fix: La corrección de un bug")]),e._v(" "),r("li",[e._v("docs: Cambios en la documentación")]),e._v(" "),r("li",[e._v("style: Cambios que no afectan el significado del código (espacios, indentación, etc.)")]),e._v(" "),r("li",[e._v("refactor: Un cambio en el código que no agrega una funcionalidad ni corrige un bug")]),e._v(" "),r("li",[e._v("perf Cambios en el código que sólo mejoran la performance")]),e._v(" "),r("li",[e._v("test: Agrega, corrige o mejora tests")]),e._v(" "),r("li",[e._v("chore: Cambios al proceso de build y herramientas auxiliares")])]),e._v(" "),r("h4",{attrs:{id:"contexto"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contexto"}},[e._v("#")]),e._v(" Contexto")]),e._v(" "),r("p",[e._v("Funcionalidad que en global el commit. Opcionalmente se puede agregar un "),r("code",[e._v("/")]),e._v(" para indicar el archivo o componente dónde fue el cambio:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  tipo(contexto/componente): descripción\n")])])]),r("h4",{attrs:{id:"descripcion"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#descripcion"}},[e._v("#")]),e._v(" Descripción")]),e._v(" "),r("p",[e._v("Descripción, no muy larga, de lo que el commit hace. Recordar, siempre en inglés!")])])}),[],!1,null,null,null);a.default=s.exports}}]);